# TODO

- #whenNot - an async method returning when a specific state is not set any more
  - or #when('Foo', 'Bar', '-Baz')
- #whenQueueDone - an async method returning when the whole queue got processed
  - used when `if (this.duringTransition()) await this.whenQueueDone();`
- `machine` factory when used without am-types highlights with an error
- rxjs integration parsing state sets coming from the network
  - parse the stream of states and "mine" complex states eg user behavior
- FSM interface?
- sideEffects: false in package.json. 
- am-network as a separate module
- TimeArray decorator for states, counting times with moment.js API
  - eg number of state sets in last 10 minutes
  - useful for counting request quota limits for API clients
  - separate npm module
  - support timezones
- implement types using variadic types TS 2.8
- move configs to ./configs
- markdown in comments, translate old cs examples
- better npm package
  - export types.ts in main cjs bundle
  - publish only the /build dir
  - include the tools, put in /bin
  - examples should use es6 modules
- investigate `[drop:implied]`
- include prettier in the workflow
- manually specified queue for piping (piping from A to B using the queue from C)
- fix change events
  - 'state-changed' (ignores tick per state changes)
  - 'tick' (fired on any change) 
  - instead of a single 'change'
- TS type generator
  - group by state, not declaration type
  - ability to output to a different dir
- maybe: State_rejected() method, triggered when a certain state wasnt accepted
  - only for target, non-auto states
- integrate cancellable generator functions with getAbort() and abort functions
  - https://github.com/getify/CAF
  - also provide abort.onAbort()
- define machines as JSONs
  - state inheritance example (via object spread)
- state validation when registering
- stop auto states when Exception is active
- #toggle(name) #api
- #has(name) #api
- history API, optional #features
  - logged as an used queue
  - add destination states
  - time?
- state groups - `FooA`, `FooB`, `FooC`, when all in group `Foo` #engine #api
  - then only one can be active at a time
  - defined by `group` or `switch` or `switch_group`
- improve logs #debug
  - more consistent
  - more levels and better assignments
- make stack traces as short as possible #debug
    - skip 2 stack frames from deferred
- make Any state a real thing #engine
  - arguments?
- make a comparison of `pipe`, `pipe negotiation` to `add`, `add & require` #docs
- synchronous throw when not in a promise #engine
- states should be in order they were requested #2 #engine
- edge case: piping negotiation, when a further state is cancelling
  - makes the piping inconsistent
  - for now, rely on the self transition
  - in the future, wait with the 3rd transition phase in the machine B
    till the negotiation is finished
- `#now()` -> `{ state: clock, state2: clock }` #api
  - `#wasLater(#now(), #now())` but with a better name
  - `#is({A: 1, b: 34}): boolean`
- GC and memory management #engine #api
  - track the context of all the bindings
  - auto unbinding unreachable transitions
  - auto unbinding unreachable promises' error handlers
  - memory leaks load tests
- transition executing the queue via generator(?) iteration #?
  - -2 stack frames
  - possibly avoid nesting when piping in the future
- extend the multi states which create new machines (eg for requests) #?
  - separate / mixin / util function / decorator
- remote state machines #?
  - separate / mixin / util function / decorator
- case insensitive state names (when strings) #api
- state as an object (shorter API calls, like `states.A.add()`) #maybe #api
  - considers signals composed out of event emitters (per each signal)
- closure compiler support (tsickle) #project
- dynamic states (???) #engine #api
- chai assertion helper #project #api
- ensure all the state lists and params are shallow copied #api #refactoring
