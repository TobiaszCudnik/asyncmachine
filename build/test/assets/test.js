// Generated by CoffeeScript 1.4.0
(function() {
  var Promise, asyncmachine, expect, sinon,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  asyncmachine = require('asyncmachine');

  expect = require('chai').expect;

  sinon = require('sinon');

  Promise = require('rsvp').Promise;

  describe("asyncmachine", function() {
    var FooMachine, assert_order, mock_states;
    FooMachine = (function(_super) {

      __extends(FooMachine, _super);

      function FooMachine() {
        return FooMachine.__super__.constructor.apply(this, arguments);
      }

      FooMachine.prototype.state_A = {};

      FooMachine.prototype.state_B = {};

      FooMachine.prototype.state_C = {};

      FooMachine.prototype.state_D = {};

      FooMachine.prototype.constructor = function(state, config) {
        return FooMachine.__super__.constructor.call(this, state, config);
      };

      return FooMachine;

    })(asyncmachine.AsyncMachine);
    mock_states = function(instance, states) {
      var inner, state, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = states.length; _i < _len; _i++) {
        state = states[_i];
        instance["" + state + "_" + state] = sinon.spy();
        instance["" + state + "_enter"] = sinon.spy();
        instance["" + state + "_exit"] = sinon.spy();
        instance["" + state + "_any"] = sinon.spy();
        instance["any_" + state] = sinon.spy();
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = states.length; _j < _len1; _j++) {
            inner = states[_j];
            if (inner === state) {
              continue;
            }
            _results1.push(instance["" + inner + "_" + state] = sinon.spy());
          }
          return _results1;
        })());
      }
      return _results;
    };
    assert_order = function(order) {
      var check, k, m, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = order.slice(0, -1);
      for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
        m = _ref[k];
        order[k] = m.calledBefore(order[k + 1]);
      }
      _ref1 = order.slice(0, -1);
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        check = _ref1[_j];
        _results.push(expect(check).to.be.ok);
      }
      return _results;
    };
    beforeEach(function() {
      return this.machine = new FooMachine('A');
    });
    it('should allow to check if single state is active');
    it("should allow for a delayed start");
    it("should accept the starting state", function() {
      return expect(this.machine.state()).to.eql(["A"]);
    });
    it("should allow to set the state", function() {
      this.machine.setState("B");
      return expect(this.machine.state()).to.eql(["B"]);
    });
    it("should allow to add a new state", function() {
      this.machine.addState("B");
      return expect(this.machine.state()).to.eql(["B", "A"]);
    });
    it("should allow to drop a state", function() {
      this.machine.setState(["B", "C"]);
      this.machine.dropState('C');
      return expect(this.machine.state()).to.eql(["B"]);
    });
    it("should throw when setting unknown state", function() {
      var func,
        _this = this;
      func = function() {
        return _this.machine.setState("unknown");
      };
      return expect(func).to["throw"]();
    });
    it('should allow to define a new state');
    it("should skip non existing states", function() {
      this.machine.A_exit = sinon.spy();
      this.machine.setState("unknown");
      return expect(this.machine.A_exit.calledOnce).not.to.be.ok;
    });
    describe("when single to single state transition", function() {
      beforeEach(function() {
        this.machine = new FooMachine('A');
        mock_states(this.machine, ['A', 'B']);
        return this.machine.setState('B');
      });
      it("should trigger the state to state transition", function() {
        return expect(this.machine.A_B.calledOnce).to.be.ok;
      });
      it("should trigger the state exit transition", function() {
        return expect(this.machine.A_exit.calledOnce).to.be.ok;
      });
      it("should trigger the transition to the new state", function() {
        return expect(this.machine.B_enter.calledOnce).to.be.ok;
      });
      it("should trigger the transition to \"Any\" state", function() {
        return expect(this.machine.A_any.calledOnce).to.be.ok;
      });
      it("should trigger the transition from \"Any\" state", function() {
        return expect(this.machine.any_B.calledOnce).to.be.ok;
      });
      it('should set the correct state', function() {
        return expect(this.machine.state()).to.eql(['B']);
      });
      return it("should remain the correct order", function() {
        var order;
        order = [this.machine.A_exit, this.machine.A_B, this.machine.A_any, this.machine.any_B, this.machine.B_enter];
        return assert_order(order);
      });
    });
    describe("when single to multi state transition", function() {
      beforeEach(function() {
        this.machine = new FooMachine('A');
        mock_states(this.machine, ['A', 'B', 'C']);
        return this.machine.setState(['B', 'C']);
      });
      it("should trigger the state to state transitions", function() {
        expect(this.machine.A_B.calledOnce).to.be.ok;
        return expect(this.machine.A_C.calledOnce).to.be.ok;
      });
      it("should trigger the state exit transition", function() {
        return expect(this.machine.A_exit.calledOnce).to.be.ok;
      });
      it("should trigger the transition to new states", function() {
        expect(this.machine.B_enter.calledOnce).to.be.ok;
        return expect(this.machine.C_enter.calledOnce).to.be.ok;
      });
      it("should trigger the transition to \"Any\" state", function() {
        return expect(this.machine.A_any.calledOnce).to.be.ok;
      });
      it("should trigger the transition from \"Any\" state", function() {
        expect(this.machine.any_B.calledOnce).to.be.ok;
        return expect(this.machine.any_C.calledOnce).to.be.ok;
      });
      it('should set the correct state', function() {
        return expect(this.machine.state()).to.eql(['B', 'C']);
      });
      return it("should remain the correct order", function() {
        var order;
        order = [this.machine.A_exit, this.machine.A_B, this.machine.A_C, this.machine.A_any, this.machine.any_B, this.machine.B_enter, this.machine.any_C, this.machine.C_enter];
        return assert_order(order);
      });
    });
    describe("when multi to single state transition", function() {
      beforeEach(function() {
        this.machine = new FooMachine(['A', 'B']);
        mock_states(this.machine, ['A', 'B', 'C']);
        return this.machine.setState(['C']);
      });
      it("should trigger the state to state transitions", function() {
        expect(this.machine.B_C.calledOnce).to.be.ok;
        return expect(this.machine.A_C.calledOnce).to.be.ok;
      });
      it("should trigger the state exit transition", function() {
        expect(this.machine.A_exit.calledOnce).to.be.ok;
        return expect(this.machine.B_exit.calledOnce).to.be.ok;
      });
      it("should trigger the transition to the new state", function() {
        return expect(this.machine.C_enter.calledOnce).to.be.ok;
      });
      it("should trigger the transition to \"Any\" state", function() {
        expect(this.machine.A_any.calledOnce).to.be.ok;
        return expect(this.machine.B_any.calledOnce).to.be.ok;
      });
      it("should trigger the transition from \"Any\" state", function() {
        return expect(this.machine.any_C.calledOnce).to.be.ok;
      });
      it('should set the correct state', function() {
        return expect(this.machine.state()).to.eql(['C']);
      });
      return it("should remain the correct order", function() {
        var order;
        order = [this.machine.A_exit, this.machine.A_C, this.machine.A_any, this.machine.B_exit, this.machine.B_C, this.machine.B_any, this.machine.any_C, this.machine.C_enter];
        return assert_order(order);
      });
    });
    describe("when multi to multi state transition", function() {
      beforeEach(function() {
        this.machine = new FooMachine(['A', 'B']);
        mock_states(this.machine, ['A', 'B', 'C', 'D']);
        return this.machine.setState(['D', 'C']);
      });
      it("should trigger the state to state transitions", function() {
        expect(this.machine.A_C.calledOnce).to.be.ok;
        expect(this.machine.A_D.calledOnce).to.be.ok;
        expect(this.machine.B_C.calledOnce).to.be.ok;
        return expect(this.machine.B_D.calledOnce).to.be.ok;
      });
      it("should trigger the state exit transition", function() {
        expect(this.machine.A_exit.calledOnce).to.be.ok;
        return expect(this.machine.B_exit.calledOnce).to.be.ok;
      });
      it("should trigger the transition to the new state", function() {
        expect(this.machine.C_enter.calledOnce).to.be.ok;
        return expect(this.machine.D_enter.calledOnce).to.be.ok;
      });
      it("should trigger the transition to \"Any\" state", function() {
        expect(this.machine.A_any.calledOnce).to.be.ok;
        return expect(this.machine.B_any.calledOnce).to.be.ok;
      });
      it("should trigger the transition from \"Any\" state", function() {
        expect(this.machine.any_C.calledOnce).to.be.ok;
        return expect(this.machine.any_D.calledOnce).to.be.ok;
      });
      it('should set the correct state', function() {
        return expect(this.machine.state()).to.eql(['D', 'C']);
      });
      return it("should remain the correct order", function() {
        var order;
        order = [this.machine.A_exit, this.machine.A_D, this.machine.A_C, this.machine.A_any, this.machine.B_exit, this.machine.B_D, this.machine.B_C, this.machine.B_any, this.machine.any_D, this.machine.D_enter, this.machine.any_C, this.machine.C_enter];
        return assert_order(order);
      });
    });
    describe("when transitioning to an active state", function() {
      beforeEach(function() {
        this.machine = new FooMachine(['A', 'B']);
        mock_states(this.machine, ['A', 'B', 'C', 'D']);
        return this.machine.setState(['A']);
      });
      it('shouldn\'t trigger transition methods', function() {
        expect(this.machine.A_exit.called).not.to.be.ok;
        expect(this.machine.A_any.called).not.to.be.ok;
        return expect(this.machine.any_A.called).not.to.be.ok;
      });
      return it('should remain in the requested state', function() {
        return expect(this.machine.state()).to.eql(['A']);
      });
    });
    describe('when order is defined by the depends attr', function() {
      beforeEach(function() {
        this.machine = new FooMachine(['A', 'B']);
        mock_states(this.machine, ['A', 'B', 'C', 'D']);
        this.machine.state_C.depends = ['D'];
        this.machine.state_A.depends = ['B'];
        return this.machine.setState(['C', 'D']);
      });
      describe('when entering', function() {
        return it('should handle dependand states first', function() {
          var order;
          order = [this.machine.A_D, this.machine.A_C, this.machine.any_D, this.machine.D_enter, this.machine.any_C, this.machine.C_enter];
          return assert_order(order);
        });
      });
      return describe('when exiting', function() {
        return it('should handle dependand states last', function() {
          var order;
          order = [this.machine.B_exit, this.machine.B_D, this.machine.B_C, this.machine.B_any, this.machine.A_exit, this.machine.A_D, this.machine.A_C, this.machine.A_any];
          return assert_order(order);
        });
      });
    });
    describe('when one state blocks another', function() {
      beforeEach(function() {
        this.machine = new FooMachine(['A', 'B']);
        mock_states(this.machine, ['A', 'B', 'C', 'D']);
        this.machine.state_C = {
          blocks: ['D']
        };
        return this.machine.setState('D');
      });
      describe('and they are set simultaneously', function() {
        beforeEach(function() {
          return this.ret = this.machine.setState(['C', 'D']);
        });
        it('should skip the second state', function() {
          return expect(this.machine.state()).to.eql(['C']);
        });
        it('should return false', function() {
          return expect(this.ret).to.eql(false);
        });
        return afterEach(function() {
          return delete this.ret;
        });
      });
      describe('and blocking one is added', function() {
        return it('should unset the blocked one', function() {
          this.machine.addState(['C']);
          return expect(this.machine.state()).to.eql(['C']);
        });
      });
      return describe('and cross blocking one is added', function() {
        beforeEach(function() {
          return this.machine.state_D = {
            blocks: ['C']
          };
        });
        describe('using setState', function() {
          it('should unset the old one', function() {
            this.machine.setState('C');
            return expect(this.machine.state()).to.eql(['C']);
          });
          return it('should work in both ways', function() {
            this.machine.setState('C');
            expect(this.machine.state()).to.eql(['C']);
            this.machine.setState('D');
            return expect(this.machine.state()).to.eql(['D']);
          });
        });
        return describe('using addState', function() {
          it('should unset the old one', function() {
            this.machine.addState('C');
            return expect(this.machine.state()).to.eql(['C']);
          });
          return it('should work in both ways', function() {
            this.machine.addState('C');
            expect(this.machine.state()).to.eql(['C']);
            this.machine.addState('D');
            return expect(this.machine.state()).to.eql(['D']);
          });
        });
      });
    });
    describe('when state is implied', function() {
      beforeEach(function() {
        this.machine = new FooMachine(['A']);
        mock_states(this.machine, ['A', 'B', 'C', 'D']);
        this.machine.state_C = {
          implies: ['D']
        };
        this.machine.state_A = {
          blocks: ['D']
        };
        return this.machine.setState(['C']);
      });
      it('should be activated', function() {
        return expect(this.machine.state()).to.eql(['C', 'D']);
      });
      return it('should be skipped if blocked at the same time', function() {
        this.machine.setState(['A', 'D']);
        return expect(this.machine.state()).to.eql(['A']);
      });
    });
    describe('when state requires another one', function() {
      beforeEach(function() {
        this.machine = new FooMachine(['A']);
        mock_states(this.machine, ['A', 'B', 'C', 'D']);
        return this.machine.state_C = {
          requires: ['D']
        };
      });
      it('should be set when required state is active', function() {
        this.machine.setState(['C', 'D']);
        return expect(this.machine.state()).to.eql(['C', 'D']);
      });
      return it('should\'t be set when required state isn\'t active', function() {
        this.machine.setState(['C', 'A']);
        return expect(this.machine.state()).to.eql(['A']);
      });
    });
    describe('when state is changed', function() {
      beforeEach(function() {
        this.machine = new FooMachine('A');
        return mock_states(this.machine, ['A', 'B', 'C', 'D']);
      });
      describe('and transition is canceled', function() {
        beforeEach(function() {
          return this.machine.D_enter = function() {
            return false;
          };
        });
        describe('when setting a new state', function() {
          beforeEach(function() {
            return this.ret = this.machine.setState('D');
          });
          it('should return false', function() {
            return expect(this.machine.setState('D')).not.to.be.ok;
          });
          return it('should not change the previous state', function() {
            return expect(this.machine.state()).to.eql(['A']);
          });
        });
        return describe('when adding an additional state', function() {
          beforeEach(function() {
            return this.ret = this.machine.addState('D');
          });
          it('should return false', function() {
            return expect(this.ret).not.to.be.ok;
          });
          return it('should not change the previous state', function() {
            return expect(this.machine.state()).to.eql(['A']);
          });
        });
      });
      describe('and transition is successful', function() {
        return it('should return true', function() {
          return expect(this.machine.setState('D')).to.be.ok;
        });
      });
      it('should provide previous state information', function(done) {
        this.machine.D_enter = function() {
          expect(this.state()).to.eql(['A']);
          return done();
        };
        return this.machine.setState('D');
      });
      it('should provide target state information', function(done) {
        this.machine.D_enter = function(target) {
          expect(target).to.eql(['D']);
          return done();
        };
        return this.machine.setState('D');
      });
      describe('with arguments', function() {
        beforeEach(function() {
          return this.machine.state_D = {
            implies: ['B'],
            blocks: ['A']
          };
        });
        describe('and synchronous', function() {
          beforeEach(function() {
            this.machine.setState('A', 'C');
            this.machine.setState('D', 'foo', 2);
            return this.machine.dropState('C', 'foo', 2);
          });
          describe('and is explicit', function() {
            it('should forward arguments to exit states', function() {
              return expect(this.machine.C_exit.calledWith('foo', 2)).to.be.ok;
            });
            return it('should forward arguments to enter states', function() {
              return expect(this.machine.D_enter.calledWith('foo', 2)).to.be.ok;
            });
          });
          return describe('and is non-explicit', function() {
            it('should not forward arguments to exit states', function() {
              return expect(this.machine.A_exit.calledWith('foo', 2)).not.to.be.ok;
            });
            return it('should not forward arguments to enter states', function() {
              return expect(this.machine.B_enter.calledWith('foo', 2)).not.to.be.ok;
            });
          });
        });
        return describe('and delayed', function() {
          beforeEach(function(done) {
            var _this = this;
            return setTimeout(function() {
              _this.machine.setStateLater('A', 'C');
              _this.machine.setStateLater('D', 'foo', 2);
              _this.machine.dropStateLater('C', 'foo', 2);
              return done();
            }, 0);
          });
          describe('and is explicit', function() {
            it('should forward arguments to exit states', function() {
              return expect(this.machine.C_exit.calledWith('foo', 2)).to.be.ok;
            });
            return it('should forward arguments to enter states', function() {
              return expect(this.machine.D_enter.calledWith('foo', 2)).to.be.ok;
            });
          });
          return describe('and is non-explicit', function() {
            it('should not forward arguments to exit states', function() {
              return expect(this.machine.A_exit.calledWith('foo', 2)).not.to.be.ok;
            });
            return it('should not forward arguments to enter states', function() {
              return expect(this.machine.B_enter.calledWith('foo', 2)).not.to.be.ok;
            });
          });
        });
      });
      describe('and delayed', function() {
        beforeEach(function() {
          return this.ret = this.machine.setStateLater('D');
        });
        it('should return a promise', function() {
          return expect(this.ret instanceof Promise).to.be.ok;
        });
        it('should execute the change', function(done) {
          var _this = this;
          this.ret.resolve();
          return this.ret.then(function() {
            expect(_this.machine.any_D.calledOnce).to.be.ok;
            expect(_this.machine.D_enter.calledOnce).to.be.ok;
            return done();
          });
        });
        it('should expose a ref to the last promise', function() {
          return expect(this.machine.last_promise).to.equal(this.ret);
        });
        return describe('and then canceled', function() {
          beforeEach(function() {
            return this.ret.reject();
          });
          return it('should not execute the change', function() {
            expect(this.machine.any_D.called).not.to.be.ok;
            return expect(this.machine.D_enter.called).not.to.be.ok;
          });
        });
      });
      describe('and active state is also the target one', function() {
        it('should trigger self transition at the very beggining', function() {
          var order;
          this.machine.setState(['A', 'B']);
          order = [this.machine.A_A, this.machine.any_B, this.machine.B_enter];
          return assert_order(order);
        });
        it('should be executed only for explicitly called states');
        it('should be cancellable', function() {
          this.machine.A_A = sinon.stub().returns(false);
          this.machine.setState(['A', 'B']);
          expect(this.machine.A_A.calledOnce).to.be.ok;
          return expect(this.machine.any_B.called).not.to.be.ok;
        });
        return after(function() {
          return delete this.machine.A_A;
        });
      });
      return describe('should trigger events', function() {
        beforeEach(function() {
          this.machine = new FooMachine('A');
          mock_states(this.machine, ['A', 'B', 'C', 'D']);
          this.machine.setState(['A', 'C']);
          this.machine.on('A._.A', this.A_A = sinon.spy());
          this.machine.on('B.enter', this.B_enter = sinon.spy());
          this.machine.on('C.exit', this.C_exit = sinon.spy());
          this.machine.on('setState', this.setState = sinon.spy());
          this.machine.on('cancelTransition', this.cancelTransition = sinon.spy());
          this.machine.on('addState', this.addState = sinon.spy());
          return this.machine.setState(['A', 'B']);
        });
        afterEach(function() {
          delete this.C_exit;
          delete this.A_A;
          delete this.B_enter;
          delete this.addState;
          delete this.setState;
          return delete this.cancelTransition;
        });
        it('for self transitions', function() {
          return expect(this.A_A.called).to.be.ok;
        });
        it('for enter transitions', function() {
          return expect(this.B_enter.called).to.be.ok;
        });
        it('for exit transtions', function() {
          return expect(this.C_exit.called).to.be.ok;
        });
        it('which can cancel the transition', function() {
          this.machine.on('D_enter', sinon.stub().returns(false));
          this.machine.setState('D');
          return expect(this.machine.D_any.called).not.to.be.ok;
        });
        it('for setting a new state', function() {
          return expect(this.setState.called).to.be.ok;
        });
        it('for pushing a new state', function() {
          return expect(this.addState.called).to.be.ok;
        });
        return it('for cancelling the transition', function() {
          return expect(this.cancelTransition.called).to.be.ok;
        });
      });
    });
    describe('Events', function() {
      var EventMachine;
      EventMachine = (function(_super) {

        __extends(EventMachine, _super);

        function EventMachine() {
          return EventMachine.__super__.constructor.apply(this, arguments);
        }

        EventMachine.prototype.state_TestNamespace = {};

        return EventMachine;

      })(FooMachine);
      beforeEach(function() {
        return this.machine = new EventMachine('A');
      });
      describe('should support states', function() {
        return it('by triggering the listener at once for active states', function() {
          var l1;
          l1 = sinon.stub();
          this.machine.on('A', l1);
          return expect(l1.calledOnce).to.be.ok;
        });
      });
      describe('should support namespaces', function() {
        describe('with wildcards', function() {
          beforeEach(function() {
            this.listeners = [];
            this.listeners.push(sinon.stub());
            this.listeners.push(sinon.stub());
            this.listeners.push(sinon.stub());
            this.machine.on('enter.Test', this.listeners[0]);
            this.machine.on('enter', this.listeners[1]);
            this.machine.on('A', this.listeners[2]);
            return this.machine.setState(['TestNamespace', 'B']);
          });
          it('should handle "enter.Test" sub event', function() {
            return expect(this.listeners[0].callCount).to.eql(1);
          });
          it('should handle "enter.*" sub event', function() {
            return expect(this.listeners[1].calledTwice).to.be.ok;
          });
          return it('should handle "A" sub events', function() {
            return expect(this.listeners[2].callCount).to.eql(4);
          });
        });
        return it('for all transitions', function() {
          var l1, l2;
          l1 = sinon.stub();
          l2 = sinon.stub();
          this.machine.on('Test.Namespace.enter', l1);
          this.machine.on('A._.Test.Namespace', l2);
          this.machine.setState('TestNamespace');
          expect(l1.calledOnce).to.be.ok;
          return expect(l2.calledOnce).to.be.ok;
        });
      });
      return describe('piping', function() {
        it('should forward a specific state', function() {
          var emitter;
          emitter = new EventMachine('A');
          this.machine.pipeForward('B', emitter);
          this.machine.setState('B');
          return expect(emitter.state()).to.eql(['B', 'A']);
        });
        it('should forward a specific state as a different one', function() {
          var emitter;
          emitter = new EventMachine('A');
          this.machine.pipeForward('B', emitter, 'C');
          this.machine.setState('B');
          return expect(emitter.state()).to.eql(['C', 'A']);
        });
        it('should invert a specific state as a different one', function() {
          var emitter;
          emitter = new EventMachine('A');
          this.machine.pipeInvert('A', emitter, 'C');
          this.machine.setState('B');
          return expect(emitter.state()).to.eql(['C', 'A']);
        });
        it('should forward a whole machine', function() {
          var machine2;
          machine2 = new EventMachine(['A', 'D']);
          expect(machine2.state()).to.eql(['A', 'D']);
          this.machine.pipeForward(machine2);
          this.machine.setState(['B', 'C']);
          return expect(machine2.state()).to.eql(['C', 'B', 'D']);
        });
        return it('can be turned off');
      });
    });
    return describe('bugs', function() {
      return it('should trigger the enter state of a subclass', function() {
        var Sub, sub;
        this.a_enter_spy = sinon.spy();
        this.b_enter_spy = sinon.spy();
        Sub = (function(_super) {

          __extends(Sub, _super);

          function Sub() {
            return Sub.__super__.constructor.apply(this, arguments);
          }

          Sub.prototype.state_A = {};

          Sub.prototype.state_B = {};

          Sub.prototype.A_enter = Sub.a_enter_spy;

          Sub.prototype.B_enter = Sub.b_enter_spy;

          return Sub;

        })(asyncmachine.AsyncMachine);
        mock_states(Sub.prototype, ['A', 'B']);
        sub = new Sub('A', {
          debug: true
        });
        debugger;
        sub.setState('B');
        expect(this.a_enter_spy.calledOnce).to.be.ok;
        return expect(this.B_enter_spy.calledOnce).to.be.ok;
      });
    });
  });

}).call(this);
