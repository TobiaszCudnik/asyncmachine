// Generated by CoffeeScript 1.4.0
(function() {
  var FooMachine, expect, multistatemachine,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  multistatemachine = require('multistatemachine');

  expect = require('chai').expect;

  FooMachine = (function(_super) {

    __extends(FooMachine, _super);

    FooMachine.prototype.state_A = {};

    FooMachine.prototype.state_B = {};

    FooMachine.prototype.state_C = {};

    FooMachine.prototype.state_D = {};

    function FooMachine(state, config) {
      FooMachine.__super__.constructor.call(this, state, config);
    }

    return FooMachine;

  })(multistatemachine.MultiStateMachine);

  describe("MultiStateMachine", function() {
    var machine;
    machine = void 0;
    beforeEach(function() {
      return machine = new FooMachine('A');
    });
    it("should allow for a delayed start");
    it("should accept the starting state", function() {
      return expect(machine.state()).to.eql(["A"]);
    });
    it("should allow to change the state", function() {
      machine.setState("B");
      return expect(true).to.eql(true);
    });
    it("should return the current state", function() {
      machine.setState("B");
      return expect(machine.state()).to.eql(["B"]);
    });
    it('should allow to define a new state');
    return describe("transitions", function() {
      var mock_states;
      mock_states = function(instance, states) {
        var state, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = states.length; _i < _len; _i++) {
          state = states[_i];
          instance["" + state + "_enter"] = sinon.spy();
          instance["" + state + "_exit"] = sinon.spy();
          instance["" + state + "_Any"] = sinon.spy();
          _results.push(instance["Any_" + state] = sinon.spy());
        }
        return _results;
      };
      it("should not trigger the non existing transitions", function() {
        machine.A_exit = sinon.spy();
        machine.setState("unknown");
        return expect(machine.A_exit.called).not.to.be.ok;
      });
      describe("single to single state transition", function() {
        beforeEach(function() {
          machine = new FooMachine('A');
          mock_states(machine, ['A', 'B']);
          return machine.state('B');
        });
        it("should trigger the state exit transition", function() {
          return expect(machine.A_exit.called).to.be.ok;
        });
        it("should trigger the transition to the new state", function() {
          return expect(machine.B_enter.called).to.be.ok;
        });
        it("should trigger the transition to \"Any\" state", function() {
          return expect(machine.A_Any.called).to.be.ok;
        });
        return it("should trigger the transition from \"Any\" state", function() {
          return expect(machine.Any_B.called).to.be.ok;
        });
      });
      describe("single to multi state transition", function() {
        beforeEach(function() {
          machine = new FooMachine('A');
          mock_states(machine, ['A', 'B', 'C']);
          return machine.state(['B', 'C']);
        });
        it("should trigger the state exit transition", function() {
          return expect(machine.A_exit.called).to.be.ok;
        });
        it("should trigger the transition to new states", function() {
          expect(machine.B_enter.called).to.be.ok;
          return expect(machine.C_enter.called).to.be.ok;
        });
        it("should trigger the transition to \"Any\" state", function() {
          return expect(machine.A_Any.called).to.be.ok;
        });
        return it("should trigger the transition from \"Any\" state", function() {
          expect(machine.Any_B.called).to.be.ok;
          return expect(machine.Any_C.called).to.be.ok;
        });
      });
      describe("multi to single state transition", function() {
        beforeEach(function() {
          machine = new FooMachine(['A', 'B']);
          mock_states(machine, ['A', 'B', 'C']);
          return machine.state(['C']);
        });
        it("should trigger the state exit transition", function() {
          expect(machine.A_exit.called).to.be.ok;
          return expect(machine.B_exit.called).to.be.ok;
        });
        it("should trigger the transition to the new state", function() {
          return expect(machine.C_enter.called).to.be.ok;
        });
        it("should trigger the transition to \"Any\" state", function() {
          expect(machine.A_Any.called).to.be.ok;
          return expect(machine.B_Any.called).to.be.ok;
        });
        return it("should trigger the transition from \"Any\" state", function() {
          return expect(machine.Any_C.called).to.be.ok;
        });
      });
      describe("multi to multi state transition", function() {
        beforeEach(function() {
          machine = new FooMachine(['A', 'B']);
          mock_states(machine, ['A', 'B', 'C', 'D']);
          return machine.state(['D', 'C']);
        });
        it("should trigger the state exit transition", function() {
          expect(machine.A_exit.called).to.be.ok;
          return expect(machine.B_exit.called).to.be.ok;
        });
        it("should trigger the transition to the new state", function() {
          expect(machine.C_enter.called).to.be.ok;
          return expect(machine.D_enter.called).to.be.ok;
        });
        it("should trigger the transition to \"Any\" state", function() {
          expect(machine.A_Any.called).to.be.ok;
          return expect(machine.B_Any.called).to.be.ok;
        });
        return it("should trigger the transition from \"Any\" state", function() {
          expect(machine.Any_C.called).to.be.ok;
          return expect(machine.Any_D.called).to.be.ok;
        });
      });
      it('should be ordered according to the "depends" state attribute');
      return it('should activate other states according to the the "implies" state attribute');
    });
  });

}).call(this);
